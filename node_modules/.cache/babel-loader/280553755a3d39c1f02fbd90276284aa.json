{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixPushStateListeners = exports.pushStateEventName = void 0;\nvar pushStateEventName = '_fathomStatechange';\nexports.pushStateEventName = pushStateEventName;\nvar hasRunFixPushState = false;\n/**\n * Adds events for all pushState/etc methods. This mutates the window object, so it will only ever run once.\n */\n\nvar fixPushStateListeners = function fixPushStateListeners() {\n  if (typeof window === 'undefined' || hasRunFixPushState) return; // eslint-disable-next-line no-undef\n\n  var _window = window,\n      history = _window.history,\n      dispatchEvent = _window.dispatchEvent;\n  /**\n   * Intercepts a pushState/etc method and dispatches our custom event.\n   *\n   * @param {Function} originalMethod The original pushState/etc method to intercept.\n   * @returns {Function} New method.\n   */\n\n  var interceptMethod = function interceptMethod(originalMethod) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var output = originalMethod.apply(history, args); // eslint-disable-next-line no-undef\n\n      dispatchEvent(new Event(pushStateEventName));\n      return output;\n    };\n  };\n\n  history.pushState = interceptMethod(history.pushState);\n  history.popState = interceptMethod(history.popState);\n  history.replaceState = interceptMethod(history.replaceState);\n  hasRunFixPushState = true;\n};\n\nexports.fixPushStateListeners = fixPushStateListeners;","map":{"version":3,"sources":["/home/aizaz/Desktop/SparkAi/changes/blog1/node_modules/fathom-react/dist/utils.js"],"names":["Object","defineProperty","exports","value","fixPushStateListeners","pushStateEventName","hasRunFixPushState","window","_window","history","dispatchEvent","interceptMethod","originalMethod","_len","arguments","length","args","Array","_key","output","apply","Event","pushState","popState","replaceState"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,qBAAR,GAAgCF,OAAO,CAACG,kBAAR,GAA6B,KAAK,CAAlE;AACA,IAAIA,kBAAkB,GAAG,oBAAzB;AACAH,OAAO,CAACG,kBAAR,GAA6BA,kBAA7B;AACA,IAAIC,kBAAkB,GAAG,KAAzB;AACA;AACA;AACA;;AAEA,IAAIF,qBAAqB,GAAG,SAASA,qBAAT,GAAiC;AAC3D,MAAI,OAAOG,MAAP,KAAkB,WAAlB,IAAiCD,kBAArC,EAAyD,OADE,CACM;;AAEjE,MAAIE,OAAO,GAAGD,MAAd;AAAA,MACIE,OAAO,GAAGD,OAAO,CAACC,OADtB;AAAA,MAEIC,aAAa,GAAGF,OAAO,CAACE,aAF5B;AAGA;AACF;AACA;AACA;AACA;AACA;;AAEE,MAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBC,cAAzB,EAAyC;AAC7D,WAAO,YAAY;AACjB,WAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,CAApC,EAAqDK,IAAI,GAAG,CAAjE,EAAoEA,IAAI,GAAGL,IAA3E,EAAiFK,IAAI,EAArF,EAAyF;AACvFF,QAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;AACD;;AAED,UAAIC,MAAM,GAAGP,cAAc,CAACQ,KAAf,CAAqBX,OAArB,EAA8BO,IAA9B,CAAb,CALiB,CAKiC;;AAElDN,MAAAA,aAAa,CAAC,IAAIW,KAAJ,CAAUhB,kBAAV,CAAD,CAAb;AACA,aAAOc,MAAP;AACD,KATD;AAUD,GAXD;;AAaAV,EAAAA,OAAO,CAACa,SAAR,GAAoBX,eAAe,CAACF,OAAO,CAACa,SAAT,CAAnC;AACAb,EAAAA,OAAO,CAACc,QAAR,GAAmBZ,eAAe,CAACF,OAAO,CAACc,QAAT,CAAlC;AACAd,EAAAA,OAAO,CAACe,YAAR,GAAuBb,eAAe,CAACF,OAAO,CAACe,YAAT,CAAtC;AACAlB,EAAAA,kBAAkB,GAAG,IAArB;AACD,CA9BD;;AAgCAJ,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixPushStateListeners = exports.pushStateEventName = void 0;\nvar pushStateEventName = '_fathomStatechange';\nexports.pushStateEventName = pushStateEventName;\nvar hasRunFixPushState = false;\n/**\n * Adds events for all pushState/etc methods. This mutates the window object, so it will only ever run once.\n */\n\nvar fixPushStateListeners = function fixPushStateListeners() {\n  if (typeof window === 'undefined' || hasRunFixPushState) return; // eslint-disable-next-line no-undef\n\n  var _window = window,\n      history = _window.history,\n      dispatchEvent = _window.dispatchEvent;\n  /**\n   * Intercepts a pushState/etc method and dispatches our custom event.\n   *\n   * @param {Function} originalMethod The original pushState/etc method to intercept.\n   * @returns {Function} New method.\n   */\n\n  var interceptMethod = function interceptMethod(originalMethod) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var output = originalMethod.apply(history, args); // eslint-disable-next-line no-undef\n\n      dispatchEvent(new Event(pushStateEventName));\n      return output;\n    };\n  };\n\n  history.pushState = interceptMethod(history.pushState);\n  history.popState = interceptMethod(history.popState);\n  history.replaceState = interceptMethod(history.replaceState);\n  hasRunFixPushState = true;\n};\n\nexports.fixPushStateListeners = fixPushStateListeners;"]},"metadata":{},"sourceType":"script"}